/* this is the cup file for the mini language
 * for CS550, Assignment 2
 * Modified by Mike Kopack for CS550, 2009 Spring Qtr.
 * Should be at the same level of completeness as the Lecture 2c
 * C++ version.
 */

import java_cup.runtime.*;
import java.util.*;

action code {:
	/* code inserted into CUP$actions class
	 * it is used by the code embedded the grammar */

	/* hm is used to store and retrieve values of variables */
	public HashMap hm = new HashMap();
	/* var stores the used variable names, this is not necessary
	 * but helpful to dump all the values at the end */
	public LinkedList var = new LinkedList();
        /* ft is used to store and retrieve the functions */
        public HashMap ft = new HashMap();
:}

parser code {:

	/* this part is included in the parser class */
	public static void main (String args[]) throws Exception{
		new parser(new Yylex(System.in)).parse();
	}
:}

terminal SEMI, PLUS, MINUS, TIMES, ASSIGN, LPAREN, RPAREN;
terminal IF, THEN, ELSE, FI, WHILE, DO, OD, REPEAT, UNTIL;
terminal DEFINE, PROC, END, RETURN;
terminal Integer NUMBER;
terminal COMMA;
terminal String ID;
/* list terminals */
terminal LBRACKET, RBRACKET, CONCAT;
terminal CONS, CAR, CDR, NULLP, INTP, LISTP;

non terminal Program program;
non terminal StatementList statement_list;
non terminal ParamList param_list;
non terminal ExpressionList expr_list;
non terminal Statement statement, assign_statement, if_statement, while_statement, repeat_statement, define_statement, return_statement;
non terminal Expr expr, car_expr;
non terminal NumExpr num_expr, term, factor, funcall, nullp_expr, intp_expr, listp_expr;
non terminal ListExpr list_expr, list_term, cons_expr, cdr_expr;

/* program */
program ::=
	statement_list:list
	{:
		Program program = new Program(list);
		program.eval(hm, ft, var);
		program.dump(hm, ft, var);
	:};

/* statements */
statement_list ::=
	statement:s
	{:
		RESULT = new StatementList(s);
	:} |
	statement:s SEMI statement_list:sl 
	{:
		/* insert a new statement at the end of the existing statement list */
		sl.insert(s); RESULT = sl;
	:};

statement ::=
	assign_statement:a
	{:
		RESULT = a;
	:} |
	define_statement:d
	{:
		RESULT = d;
	:} |
	if_statement:i
	{:
		RESULT = i;
	:} |
	while_statement:w
	{:
		RESULT = w;
	:} |
	return_statement:rs
	{:
		RESULT = rs;
	:} |
	repeat_statement:r
	{:
		RESULT = r;
	:};

assign_statement ::=
	ID:i ASSIGN expr:e
	{:
		RESULT = new AssignStatement(i,e); 
	:};

define_statement ::=
	DEFINE ID:i PROC LPAREN param_list:pl RPAREN statement_list:sl END
	{:
		RESULT = new DefineStatement(i,new Proc(pl,sl));
	:};

if_statement ::=
	IF num_expr:e THEN statement_list:s1 ELSE statement_list:s2 FI
	{:
		RESULT = new IfStatement(e,s1,s2);
	:};

while_statement ::=
	WHILE num_expr:e DO statement_list:s OD
	{:
		RESULT = new WhileStatement(e,s);
	:};

repeat_statement ::=
	REPEAT statement_list:sl UNTIL num_expr:e
	{:
		RESULT = new RepeatStatement(sl,e);
	:};

return_statement ::=
	RETURN expr:e
	{:
		RESULT = new ReturnStatement(e);
	:};

param_list ::=
	ID:i COMMA param_list:pl
	{:
		RESULT = new ParamList(i,pl);
	:} |
	ID:i
	{:
		RESULT = new ParamList(i);
	:};

/* general expression */
expr ::=
	num_expr:e
	{:
		RESULT = e;
	:} |
	list_expr:e
	{:
		RESULT = e;
	:} |
	car_expr:e
	{:
		RESULT = e;
	:};

car_expr ::=
	CAR LPAREN list_expr:le RPAREN
	{:
		RESULT = new Car(le);
	:};

/* number expression */
num_expr ::=
	num_expr:e PLUS term:t
	{:
		RESULT = new Plus(e,t);
	:} |
	num_expr:e MINUS term:t
	{:
		RESULT = new Minus(e,t);
	:} |
	term:t
	{:
		RESULT = t;
	:} |
	nullp_expr:ne
	{:
		RESULT = ne;
	:} |
	intp_expr:ie
	{:
		RESULT = ie;
	:} |
	listp_expr:le
	{:
		RESULT = le;
	:};

term ::=
	term:t TIMES factor:f
	{:
		RESULT = new Times(t,f);
	:} |
	factor:f
	{:
		RESULT = f;
	:};

factor ::=
	LPAREN num_expr:e RPAREN
	{:
		RESULT = e;
	:} |
	NUMBER:n
	{:
		RESULT = new Number(n);
	:} |
	ID:i
	{:
		RESULT = new Ident(i);
	:} |
	funcall:fc
	{:
		RESULT = fc;
	:};

// ! here funcall is derived from num_expr, but in the java code it extends Expr 
funcall ::=
	ID:i LPAREN expr_list:el RPAREN
	{:
		RESULT = new FunctionCall(i,el);
	:};

nullp_expr ::=
	NULLP LPAREN list_expr:le RPAREN
	{:
		RESULT = new NullP(le);
	:};

intp_expr ::=
	INTP LPAREN expr:e RPAREN
	{:
		RESULT = new IntP(e);
	:};

listp_expr ::=
	LISTP LPAREN expr:e RPAREN
	{:
		RESULT = new ListP(e);
	:};

/* list expression */
list_expr ::=
	list_term:lt
	{:
		RESULT = lt;
	:} |
	list_expr:le CONCAT list_term:lt
	{:
		RESULT = new Cons(le,lt);
	:};

list_term ::=
	LBRACKET expr_list:el RBRACKET
	{:
		RESULT = new ListExpr(el);
	:} |
	LBRACKET RBRACKET
	{:
		RESULT = new ListExpr();
	:} |
	cons_expr:ce
	{:
		RESULT = ce;
	:} |
	cdr_expr:ce
	{:
		RESULT = ce;
	:};

expr_list ::=
	expr:ex COMMA expr_list:el
	{:
		RESULT = new ExpressionList(ex,el);
	:} |
	expr:ex 
	{:
		RESULT = new ExpressionList(ex);
	:};

cons_expr ::=
	CONS LPAREN expr:e COMMA list_expr:le RPAREN
	{:
		RESULT = new Cons(e,le);
	:};

cdr_expr ::=
	CDR LPAREN list_expr:le RPAREN
	{:
		RESULT = new Cdr(le);
	:};
